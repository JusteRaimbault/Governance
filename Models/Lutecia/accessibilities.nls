
;;;;;;;;;;;;;;
;; accessibility and utility functions
;;;;;;;;;;;;;;


;;
; update acc, form factor and utilities
to compute-patches-variables
  compute-patches-accessibilities
  compute-patches-form-factor
  compute-patches-utilities
  
  ; color patches here, for more understanding of the infrastructure explo process
  display:color-patches
  
end


;;
;  Compute patches accessibilities
;   given current distributions and effective distance matrix
to compute-patches-accessibilities
  ask patches [
     set prev-accessibility a-to-e-accessibility + e-to-a-accessibility
     ; only one csp for now
     set a-to-e-accessibility actives * scalar-product (global:patches-employments-list) map [exp (- global:lambda-accessibility * ?)] (matrix:get-row global:effective-distance-matrix number)
     set e-to-a-accessibility employments * scalar-product (global:patches-actives-list) map [exp (- global:lambda-accessibility * ?)] (matrix:get-row global:effective-distance-matrix number)
     
     set current-accessibility a-to-e-accessibility + e-to-a-accessibility
     
     ; update also travel distances
     set a-to-e-distance actives * scalar-product (global:patches-employments-list) (matrix:get-row global:effective-distance-matrix number)
     set e-to-a-distance employments * scalar-product (global:patches-actives-list) (matrix:get-row global:effective-distance-matrix number)
  ]
end

;;
; Compute form factor, as couples [a-form-factor,e-form-factor]
;
to compute-patches-form-factor
  ; only one csp : nothing to do
  ask patches [
    set form-factor (list actives-form-factor employments-form-factor)
  ]
end


;;
; patches utilities
;  note : could be in same loop as accessibilities ? more flexibility.
to compute-patches-utilities
  ask patches [
    set a-utility (a-to-e-accessibility ^ global:gamma-cobb-douglas-a) * ((first form-factor) ^ (1 - global:gamma-cobb-douglas-a))
    set e-utility (e-to-a-accessibility ^ global:gamma-cobb-douglas-e) * ((last form-factor) ^ (1 - global:gamma-cobb-douglas-e))
  ]
  
  ; renormalize utilities
  let ma-a max [a-utility] of patches let ma-e max [e-utility] of patches
  if ma-a > 0 [ask patches [set a-utility a-utility / ma-a]]
  if ma-e > 0 [ask patches [set e-utility e-utility / ma-e]]
end



;;
; mean accessibility of employments and actives
;  normalized by total quantities of employment and actives ? YES but not on patchset, all patches !
;
;  -- symmetric a-e --
to-report accessibilities:mean-accessibility [patchset]
  ifelse sum [actives] of patches > 0 and sum [employments] of patches > 0 and count patchset > 0 [
    report (sum [a-to-e-accessibility + e-to-a-accessibility] of patchset) / (2 * (sum [actives] of patches) * (sum [employments] of patches))
  ][report 0]
end



;;
; form factor for actives :
;  they search to flee from density, both of actives and employments
to-report actives-form-factor
  if actives = 0 or employments = 0 [report 1]
  report 1 / (actives * employments)
end


;;
; form factor for employments:
;  take only accessibility into account (for now)
to-report employments-form-factor
  report 1
end


