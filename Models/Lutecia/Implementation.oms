
import java.util.Date
import java.text.SimpleDateFormat

logger.level("FINE")


// Parameters
val lambdaAcc = Val[Double]
val networkSpeed = Val[Double]
val gammaCDA=Val[Double]
val gammaCDE=Val[Double]
val betaDC=Val[Double]
val relocationRate=Val[Double]

val finalTime = Val[Double]
val worldSize = Val[Double]
val numberTerritories = Val[Double]

val id = Val[Int]
val replication = Val[Int]


// spatial configurations
val actives = Val[RasterLayer]
val employments = Val[RasterLayer]


// fixed parameters
val tf = 4
val ws = 15
val territs = 3


// reporters

// full trajectory of models
val activesTrajectoriesNL5 = Val[Array[RasterLayer]]
val activesTrajectoriesNL6 = Val[Array[RasterLayer]]
val activesTrajectoriesScala = Val[Array[RasterLayer]]

val employmentsTrajectoriesNL5 = Val[Array[RasterLayer]]
val employmentsTrajectoriesNL6 = Val[Array[RasterLayer]]
val employmentsTrajectoriesScala = Val[Array[RasterLayer]]

val distMatNL5 = Val[Array[Array[Array[Double]]]]
val distMatNL6 = Val[Array[Array[Array[Double]]]]
val distMatScala = Val[Array[Array[Array[Double]]]]

val accessibilitiesNL5 = Val[Array[RasterLayer]]
val accessibilitiesNL6 = Val[Array[RasterLayer]]
val accessibilitiesScala = Val[Array[RasterLayer]]

val aUtilitiesNL5 = Val[Array[RasterLayer]]
val aUtilitiesNL6 = Val[Array[RasterLayer]]
val aUtilitiesScala = Val[Array[RasterLayer]]

val eUtilitiesNL5 = Val[Array[RasterLayer]]
val eUtilitiesNL6 = Val[Array[RasterLayer]]
val eUtilitiesScala = Val[Array[RasterLayer]]


val avgstepdiffactives56 = Val[Array[Double]]
val avgstepdiffemployments56  = Val[Array[Double]]
val avgstepdiffdist56  = Val[Array[Double]]
val avgstepdiffaccess56  = Val[Array[Double]]
val avgstepdiffautility56  = Val[Array[Double]]
val avgstepdiffeutilty56  = Val[Array[Double]]
val stepdiffactives56  = Val[Array[Double]]
val stepdiffemployments56 = Val[Array[Double]]
val stepdiffdist56 = Val[Array[Double]]
val stepdiffaccess56 = Val[Array[Double]]
val stepdiffautility56 = Val[Array[Double]]
val stepdiffeutility56 = Val[Array[Double]]
val avgstepdiffactives6s = Val[Array[Double]]
val avgstepdiffemployments6s = Val[Array[Double]]
val avgstepdiffdist6s = Val[Array[Double]]
val avgstepdiffaccess6s = Val[Array[Double]]
val avgstepdiffautility6s = Val[Array[Double]]
val avgstepdiffeutilty6s = Val[Array[Double]]
val stepdiffactives6s = Val[Array[Double]]
val stepdiffemployments6s = Val[Array[Double]]
val stepdiffdist6s = Val[Array[Double]]
val stepdiffaccess6s = Val[Array[Double]]
val stepdiffautility6s = Val[Array[Double]]
val stepdiffeutility6s = Val[Array[Double]]


// NetLogo models

// experiments-luti:setup-experiment-luti [relocationRate gammaA gammaE betaDC lambdaacc nwspeed scenario finalTime worldSize rnd-seed]
val cmds = List(
  "experiments-luti:setup-experiment-luti ${relocationRate} ${gammaCDA} ${gammaCDE} ${betaDC} ${lambdaAcc} ${networkSpeed} -1 ${finalTime} ${worldSize} \"external\" ${replication}",
  "experiments-luti:run-experiment-luti"
)


val model5 = NetLogo5Task(workDirectory / "netlogo5/HEADLESS_Lutecia.nlogo",cmds,embedWorkspace=true) set(
  inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  inputs += (actives,employments),
  inputs += actives mapped "global:setup:actives",
  inputs += employments mapped "global:setup:employments",
  outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  outputs += (actives,employments),
  outputs += activesTrajectoriesNL5 mapped "indicators:actives-raster-alltimes",
  outputs += employmentsTrajectoriesNL5 mapped "indicators:employments-raster-alltimes",
  outputs += distMatNL5 mapped "indicators:distance-matrix-alltimes true",
  outputs += accessibilitiesNL5 mapped "indicators:accessibilities-raster-alltimes",
  outputs += aUtilitiesNL5 mapped "indicators:a-utilities-raster-alltimes",
  outputs += eUtilitiesNL5 mapped "indicators:e-utilities-raster-alltimes"
)

val model6 = NetLogo6Task(workDirectory / "netlogo6/HEADLESS_Lutecia.nlogo",cmds,embedWorkspace=true) set(
  inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  inputs += (actives,employments),
  inputs += actives mapped "global:setup:actives",
  inputs += employments mapped "global:setup:employments",
  outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  inputs += (activesTrajectoriesNL5,employmentsTrajectoriesNL5,distMatNL5,accessibilitiesNL5,aUtilitiesNL5,eUtilitiesNL5),
  outputs += (activesTrajectoriesNL5,employmentsTrajectoriesNL5,distMatNL5,accessibilitiesNL5,aUtilitiesNL5,eUtilitiesNL5),
  outputs += (actives,employments),
  outputs += activesTrajectoriesNL6 mapped "indicators:actives-raster-alltimes",
  outputs += employmentsTrajectoriesNL6 mapped "indicators:employments-raster-alltimes",
  outputs += distMatNL6 mapped "indicators:distance-matrix-alltimes true",
  outputs += accessibilitiesNL6 mapped "indicators:accessibilities-raster-alltimes",
  outputs += aUtilitiesNL6 mapped "indicators:a-utilities-raster-alltimes",
  outputs += eUtilitiesNL6 mapped "indicators:e-utilities-raster-alltimes"
)



val modelscala = ScalaTask("""
    |import lutecia._
    |import lutecia.setup._
    |import lutecia.network._
    |import lutecia.indicators._
    |
    |val model = new Lutecia with SyntheticSetup 
    |   //with ExponentialMixtureGrid
    |   with ExternalGrid
    |   with GridNetwork {
    |  
    |  override def worldSize = input.worldSize.toInt
    |  override def finalTime: Int = input.finalTime.toInt
    |  override def numberTerritories: Int = input.numberTerritories.toInt
    |  override def lambda: Double = input.lambdaAcc
    |  override def beta: Double = input.betaDC
    |  override def alpha: Double = input.relocationRate
    |  override def gammaA: Double = input.gammaCDA
    |  override def gammaE: Double = input.gammaCDE
    |  override def euclidianPace: Double = input.networkSpeed
    |  
    |  override def actives = input.actives
    |  override def employments= input.employments
    |}
    |
    |val result = RunModel.run(model)
    |
    |val activesTrajectoriesScala = Result.getActivesTrajectories(result).toArray
    |val employmentsTrajectoriesScala = Result.getEmploymentsTrajectories(result).toArray
    |val distMatScala = Result.getDistanceMatrices(result).toArray
    |val accessibilitiesScala = Result.getAccessibilities(result).toArray
    |val aUtilitiesScala = Result.getTrajectories(result,_.aUtility).toArray
    |val eUtilitiesScala = Result.getTrajectories(result,_.eUtility).toArray
    |""".stripMargin
) set (
   plugins += pluginsOf(lutecia.Lutecia),
   inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
   inputs += (activesTrajectoriesNL6,employmentsTrajectoriesNL6,distMatNL6,accessibilitiesNL6,aUtilitiesNL6,eUtilitiesNL6),
   inputs += (activesTrajectoriesNL5,employmentsTrajectoriesNL5,distMatNL5,accessibilitiesNL5,aUtilitiesNL5,eUtilitiesNL5),
   inputs += (actives,employments),
   outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
   outputs += (activesTrajectoriesNL6,employmentsTrajectoriesNL6,distMatNL6,accessibilitiesNL6,aUtilitiesNL6,eUtilitiesNL6),
   outputs += (activesTrajectoriesNL5,employmentsTrajectoriesNL5,distMatNL5,accessibilitiesNL5,aUtilitiesNL5,eUtilitiesNL5),
   outputs += (activesTrajectoriesScala,employmentsTrajectoriesScala,distMatScala,accessibilitiesScala,aUtilitiesScala,eUtilitiesScala)
)


val comparison = ScalaTask("""
  |def stepdiff(a1: Array[Array[Array[Double]]],a2: Array[Array[Array[Double]]]) : Array[Double] = a1.zip(a2).map{
  |     case (r1,r2) => r1.flatten.toSeq.zip(r2.flatten.toSeq).map{case (x1,x2) => 200 * math.abs(x1 - x2) / (x1 + x2)}.sum / r1.flatten.length
  |    }
  |
  |val stepdiff = activesTrajectoriesNL6.zip(employmentsTrajectoriesNL6).zip(activesTrajectoriesScala).zip(employmentsTrajectoriesScala).map{
  |   case (((a6,e6),a),e) => 400 * (a6.flatten.toSeq.zip(a.flatten.toSeq).map{
  |      case (a1,a2) => math.abs(a1 - a2)
  |    }.sum + e6.flatten.toSeq.zip(e.flatten.toSeq).map{case (e1,e2) => math.abs(e1 - e2)}.sum ) / (a6.flatten.sum + a.flatten.sum + e6.flatten.sum + e.flatten.sum)
  | }
  |
  | /*val stepdiff = distMatNL6.zip(distMatScala).map{
  |   case (d6,ds) => d6.flatten.toSeq.zip(ds.flatten.toSeq).map{case (d1,d2) => (d1 - d2)*(d1 - d2)}.sum
  | }
  |*/
  |/*val stepdiff = distMatNL6.zip(distMatScala).map{
  |   case (d6,ds) => d6.zip(ds).map{case (r1,r2) => r1.zip(r2).map{case (d1,d2) => math.abs(d1-d2)}.max}.max
  | }*/
  | /*val stepdiff = distMatScala.zip(distMatNL6).map{
  |   case (ds,d6) => d6.map{case Array(i,j,d) => math.abs(ds((i.toInt,j.toInt)) - d)}.sum
  |}*/
  |val totaldiff = stepdiff.sum
"""
) set (
  inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  inputs += (activesTrajectoriesNL6,employmentsTrajectoriesNL6,distMatNL6,accessibilitiesNL6,aUtilitiesNL6,eUtilitiesNL6),
  inputs += (activesTrajectoriesNL5,employmentsTrajectoriesNL5,distMatNL5,accessibilitiesNL5,aUtilitiesNL5,eUtilitiesNL5),
  inputs += (activesTrajectoriesScala,employmentsTrajectoriesScala,distMatScala,accessibilitiesScala,aUtilitiesScala,eUtilitiesScala),
  outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  outputs += (avgstepdiffactives56,avgstepdiffemployments56,avgstepdiffdist56,avgstepdiffaccess56,avgstepdiffautility56,avgstepdiffeutilty56),
  outputs += (stepdiffactives56,stepdiffemployments56,stepdiffdist56,stepdiffaccess56,stepdiffautility56,stepdiffeutility56),
  outputs += (avgstepdiffactives6s,avgstepdiffemployments6s,avgstepdiffdist6s,avgstepdiffaccess6s,avgstepdiffautility6s,avgstepdiffeutilty6s),
  outputs += (stepdiffactives6s,stepdiffemployments6s,stepdiffdist6s,stepdiffaccess6s,stepdiffautility6s,stepdiffeutility6s)
)

val purpose = "IMPLEMENTATION_TEST"
//val purpose = "IMPLEMENTATION"

val indics_hook = AppendToCSVFileHook(workDirectory / "exploration" / ((new SimpleDateFormat("yyyyMMdd_HHmmss")).format(new Date()))+"_"+purpose+".csv") set (
  arraysOnSingleRow := true
)

val env = LocalEnvironment(4)
//val grid = EGIEnvironment("vo.complex-systems.eu",openMOLEMemory = 4000 megabytes)



//relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id
val exploration =
  DirectSampling(
    //evaluation = ((model6 on grid by 10) -- comparison hook indics_hook) ,
    evaluation = (model5 -- model6 -- modelscala -- comparison hook indics_hook) ,
    sampling =
   ((LHS (
      2
      ,lambdaAcc in Range(0.001,0.01)
      ,networkSpeed in Range(2.5,10.0)
      ,gammaCDA in Range(0.5,1.0)
      ,gammaCDE in Range(0.5,1.0)
      ,betaDC in Range(0.5,2.0)
      ,relocationRate in Range(0.0,0.2)
    ) withIndex id) x
    (finalTime is tf) x 
    (worldSize is ws) x
    (numberTerritories is territs) x
    (ExponentialMixtureSpatialSampling(
        gridSize = Left(ws),
        centersNumber = territs,
        maxValue = Left(500.0),
        kernelRadius = Right(Seq(1.0,0.8)),
        samples = 1,
        prototypes = Seq(actives,employments)
    ) withIndex replication ) 
   )
  )


exploration
