
import java.util.Date
import java.text.SimpleDateFormat

logger.level("FINE")


// Parameters
val lambdaAcc = Val[Double]
val networkSpeed = Val[Double]
val gammaCDA=Val[Double]
val gammaCDE=Val[Double]
val betaDC=Val[Double]
val relocationRate=Val[Double]

val finalTime = Val[Double]
val worldSize = Val[Double]
val numberTerritories = Val[Double]

val id = Val[Int]
val replication = Val[Int]


// spatial configurations
val actives = Val[RasterLayer]
val employments = Val[RasterLayer]


// fixed parameters
val tf = 4
val ws = 15
val territs = 3


// reporters
val totaldiff = Val[Double]
val stepdiff = Val[Array[Double]]


// full trajectory of models
val activesTrajectoriesNL6 = Val[Array[RasterLayer]]
val employmentsTrajectoriesNL6 = Val[Array[RasterLayer]]
val activesTrajectoriesScala = Val[Array[RasterLayer]]
val employmentsTrajectoriesScala = Val[Array[RasterLayer]]
val distMatNL6 = Val[Array[Array[Array[Double]]]]
val distMatScala = Val[Array[Array[Array[Double]]]]


// experiments-luti:setup-experiment-luti [relocationRate gammaA gammaE betaDC lambdaacc nwspeed scenario finalTime worldSize rnd-seed]
val cmds = List(
  "experiments-luti:setup-experiment-luti ${relocationRate} ${gammaCDA} ${gammaCDE} ${betaDC} ${lambdaAcc} ${networkSpeed} -1 ${finalTime} ${worldSize} \"external\" ${replication}",
  "experiments-luti:run-experiment-luti"
)

val model6 = NetLogo6Task(workDirectory / "netlogo6/HEADLESS_Lutecia.nlogo",cmds,embedWorkspace=true) set(
  inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  inputs += (actives,employments),
  inputs += actives mapped "global:setup:actives",
  inputs += employments mapped "global:setup:employments",
  outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  outputs += (actives,employments),
  outputs += activesTrajectoriesNL6 mapped "indicators:actives-raster-alltimes",
  outputs += employmentsTrajectoriesNL6 mapped "indicators:employments-raster-alltimes",
  outputs += distMatNL6 mapped "indicators:distance-matrix-alltimes"
)


val modelscala = ScalaTask("""
    |import lutecia._
    |import lutecia.setup._
    |import lutecia.network._
    |import lutecia.indicators._
    |
    |val model = new Lutecia with SyntheticSetup 
    |   //with ExponentialMixtureGrid
    |   with ExternalGrid
    |   with GridNetwork {
    |  
    |  override def worldSize = input.worldSize.toInt
    |  override def finalTime: Int = input.finalTime.toInt
    |  override def numberTerritories: Int = input.numberTerritories.toInt
    |  override def lambda: Double = input.lambdaAcc
    |  override def beta: Double = input.betaDC
    |  override def alpha: Double = input.relocationRate
    |  override def gammaA: Double = input.gammaCDA
    |  override def gammaE: Double = input.gammaCDE
    |  override def euclidianPace: Double = input.networkSpeed
    |  
    |  override def actives = input.actives
    |  override def employments= input.employments
    |}
    |
    |val result = RunModel.run(model)
    |
    |val activesTrajectoriesScala = Result.getActivesTrajectories(result).toArray
    |val employmentsTrajectoriesScala = Result.getEmploymentsTrajectories(result).toArray
    |val distMatScala = Result.getDistanceMatrices(result).toArray
    |""".stripMargin
) set (
   plugins += pluginsOf(lutecia.Lutecia),
   inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
   inputs += (activesTrajectoriesNL6,employmentsTrajectoriesNL6,distMatNL6),
   inputs += (actives,employments),
   outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
   outputs += (activesTrajectoriesNL6,employmentsTrajectoriesNL6,distMatNL6),
   outputs += (activesTrajectoriesScala,employmentsTrajectoriesScala,distMatScala)
)


val comparison = ScalaTask("""
  |/*val stepdiff = activesTrajectoriesNL6.zip(employmentsTrajectoriesNL6).zip(activesTrajectoriesScala).zip(employmentsTrajectoriesScala).map{
  |   case (((a6,e6),a),e) => a6.flatten.toSeq.zip(a.flatten.toSeq).map{case (a1,a2) => (a1 - a2)*(a1 - a2)}.sum + e6.flatten.toSeq.zip(e.flatten.toSeq).map{case (e1,e2) => (e1 - e2)*(e1 - e2)}.sum
  | }*/
  |/* val stepdiff = distMatNL6.zip(distMatScala).map{
  |   case (d6,ds) => d6.flatten.toSeq.zip(ds.flatten.toSeq).map{case (d1,d2) => (d1 - d2)*(d1 - d2)}.sum
  | }*/
  |val stepdiff = distMatNL6.zip(distMatScala).map{
  |   case (d6,ds) => d6.flatten.toSeq.zip(ds.flatten.toSeq).map{case (d1,d2) => math.abs(d1 - d2)}.max
  | }
  |val totaldiff = stepdiff.sum
"""
) set (
  inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  inputs += (activesTrajectoriesNL6,employmentsTrajectoriesNL6,distMatNL6,activesTrajectoriesScala,employmentsTrajectoriesScala,distMatScala),
  outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id),
  outputs += (totaldiff,stepdiff)
)

val purpose = "IMPLEMENTATION_TEST"
//val purpose = "IMPLEMENTATION"

val indics_hook = AppendToCSVFileHook(workDirectory / "exploration" / ((new SimpleDateFormat("yyyyMMdd_HHmmss")).format(new Date()))+"_"+purpose+".csv") set (
  arraysOnSingleRow := true
)

val env = LocalEnvironment(4)
//val grid = EGIEnvironment("vo.complex-systems.eu",openMOLEMemory = 4000 megabytes)



//relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,finalTime,worldSize,numberTerritories,replication,id
val exploration =
  DirectSampling(
    //evaluation = ((model6 on grid by 10) -- comparison hook indics_hook) ,
    evaluation = (model6 -- modelscala -- comparison hook indics_hook) ,
    sampling =
   ((LHS (
      1
      ,lambdaAcc in Range(0.001,0.01)
      ,networkSpeed in Range(2.5,10.0)
      ,gammaCDA in Range(0.5,1.0)
      ,gammaCDE in Range(0.5,1.0)
      ,betaDC in Range(0.5,2.0)
      ,relocationRate in Range(0.0,1.0)
    ) withIndex id) x
    (finalTime is tf) x 
    (worldSize is ws) x
    (numberTerritories is territs) x
    (ExponentialMixtureSpatialSampling(
        gridSize = Left(ws),
        centersNumber = territs,
        maxValue = Left(500.0),
        kernelRadius = Right(Seq(1.0,0.8)),
        samples = 4,
        prototypes = Seq(actives,employments)
    ) withIndex replication ) 
   )
  )


exploration
