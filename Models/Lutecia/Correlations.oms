
import java.util.Date
import java.text.SimpleDateFormat

logger.level("FINE")


// Parameters
val lambdaAcc = Val[Double]
val networkSpeed = Val[Double]
val gammaCDA=Val[Double]
val gammaCDE=Val[Double]
val betaDC=Val[Double]
val relocationRate=Val[Double]

val id = Val[Int]
val replication = Val[Int]

// scenarios variables
val scenario=Val[Int]
val nwType=Val[String]
val centerNumber=Val[Double]
val gammaSlimeMould=Val[Double]


// reporters
val accessibilities = Val[Array[Double]]
val accessibilitiesarray = Val[Array[Double]]
val deltaActives = Val[Array[Double]]
val deltaActivesarray = Val[Array[Double]]
val employments = Val[Array[Double]]
val employmentsarray = Val[Array[Double]]
val nPatches=Val[Double]
val nPatchesarray=Val[Double]

val corAccessDev=Val[Array[Double]]
val corAccessEmployments=Val[Array[Double]]


val b=Val[Int]

// experiments-luti:setup-experiment-luti [relocationRate gammaA gammaE betaDC lambdaacc nwspeed scenario finalTime rnd-seed]
val cmds = List(
  "experiments-luti:setup-experiment-luti ${relocationRate} ${gammaCDA} ${gammaCDE} ${betaDC} ${lambdaAcc} ${networkSpeed} ${scenario} 20 ${replication}",
  "experiments-luti:run-experiment-luti"
)

val model = NetLogo5Task(workDirectory / "model/HEADLESS_Lutecia.nlogo",cmds,embedWorkspace=true) set(
  inputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,scenario,replication,id),
  outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,scenario,replication,id),
  netLogoOutputs += ("indicators:patches-alltimes-accessibilities",accessibilities),
  netLogoOutputs += ("indicators:patches-alltimes-delta-actives",deltaActives),
  netLogoOutputs += ("indicators:patches-alltimes-employments",employments),
  netLogoOutputs += ("count patches",nPatches)
)


val purpose = "TEST"
//val purpose = "CORRS"

val nReplications=3

// output
val indics_hook = AppendToCSVFileHook(workDirectory / "exploration" / ((new SimpleDateFormat("yyyyMMdd_HHmmss")).format(new Date()))+"_"+purpose+".csv") set (
  arraysOnSingleRow := true
)



val env = LocalEnvironment(4)
//val env = EGIEnvironment("vo.complex-systems.eu",openMOLEMemory = 4000 megabytes)


val replications =
 Replication (
   evaluation = (model on env),
   seed = replication,
   replications = nReplications
)


// aggregation task
/*
val flatten = ScalaTask("""
 val accessibilitiesarray = accessibilities.flatten.to[Array]
 println(accessibilitiesarray.toString)
 val deltaActivesarray = deltaActives.flatten
 val employmentsarray = employments.flatten
 val nPatchesarray = nPatches.map{_.average}.average
 println(nPatchesarray.toString)
 """)set(
  inputs += (accessibilities.toArray.toArray,deltaActives.toArray.toArray,employments.toArray.toArray,nPatches.toArray.toArray),
  outputs += (accessibilitiesarray,deltaActivesarray,employmentsarray,nPatchesarray)
)
*/

val estimateCorrs = RTask("""
        source("corrs.R")
        show(c(unlist(access)));show(c(unlist(dactives)));show(c(unlist(employments)))
        show(length(access));#show(length(access[[1]]))
        rhoaccessdev = timecorrs(c(unlist(access)),c(unlist(dactives)),n=c(unlist(n))[1],b=b)
        rhoaccessemp = timecorrs(c(unlist(access)),c(unlist(employments)),n=c(unlist(n))[1],b=b)
    """) set (
      b := nReplications,
      resources += workDirectory / "analysis/corrs.R",
      rInputs += (b,"b"),
      rInputs += (nPatches.toArray,"n"),
      rInputs += (accessibilities.toArray,"access"),
      rInputs += (deltaActives.toArray,"dactives"),
      rInputs += (employments.toArray,"employments"),
      //rInputs += (nPatches.toArray.toArray,"n"),
      //rInputs += (accessibilities.toArray.toArray,"access"),
      //rInputs += (deltaActives.toArray.toArray,"dactives"),
      //rInputs += (employments.toArray.toArray,"employments"),
      rOutputs += ("rhoaccessdev",corAccessDev),
      rOutputs += ("rhoaccessemp",corAccessEmployments)//,
      //inputs += (relocationRate.toArray.toArray,gammaCDA.toArray.toArray,gammaCDE.toArray.toArray,betaDC.toArray.toArray,lambdaAcc.toArray.toArray,networkSpeed.toArray.toArray,scenario.toArray.toArray,replication.toArray.toArray,id.toArray.toArray),
      //outputs += (relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,scenario,replication,id)
    )



//relocationRate,gammaCDA,gammaCDE,betaDC,lambdaAcc,networkSpeed,scenario,replication,id
val exploration =
  DirectSampling(
    evaluation = replications -- estimateCorrs hook indics_hook,
    sampling =
    /*(((lambdaAcc in (0.002 to 0.01 by 0.002)) x
    (networkSpeed in (2.0 to 6.0 by 2.0)) x
    (gammaCDA in (0.1 to 1.0 by 0.1))x
    (gammaCDE in (0.1 to 1.0 by 0.1))x
    (betaDC in (0.5 to 2.0 by 0.5))x
    (relocationRate in (0.1 to 1.0 by 0.1))x
    (scenario in (0 to 5 by 1))
  ) withIndex id )*/
   ((LHS (
      //500
      1
      //,lambdaAcc in Range(0.001,0.01)
      //,networkSpeed in Range(2.5,10.0)
      ,gammaCDA in Range(0.5,1.0)
      ,gammaCDE in Range(0.5,1.0)
      ,betaDC in Range(0.5,2.0)
      ,relocationRate in Range(0.0,1.0)
    ) withIndex id) x (scenario in (0 to 3 by 1)) x (lambdaAcc is 0.005) x (networkSpeed is 5.0) )//,
    //aggregation = (flatten -- (estimateCorrs hook indics_hook))
    //aggregation = (estimateCorrs hook indics_hook)
  )


exploration
